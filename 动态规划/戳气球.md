# LeetCode-312-戳气球

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

输入：`nums = [3,1,5,8]`
输出：167
解释：
`nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []`
`coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167`

## 动态规划

此处的数组会因为先戳破了哪一个而出现收缩的问题，所以此处需要关注的是区间内哪一个气球最后被戳破，最后能够获得最大值是可以计算的。

在气球被戳破后，就会数组中消失，那么数组的元素是在不断减少的，相邻的元素在不断变化。那么需要把这个问题拆分为一个能够逐个处理的子问题。此处的气球包含区间内，那么就将问题转化为把一个区间内的全部气球都戳破，能够获得最大的金币，此处就能够将区间划分为一个个子区间。

1. 动规数组：定义 `dp[i][j]` 表示对于开区间 `(i,j)` 中的气球全部戳破，能够得到的最大的金币数量
2. 数组推导：对于 `dp[i][j]` 当 `i+1>=j` 时没有气球，对于 `j>=i+2` 时，先戳破哪一个则有 `i+1,...,j-1` 种选择，并且在选择后，回导致区间内的值发生变化 选取 `nums[k]` 那么 `dp[i][k],dp[k][j]` 此时的 `k` 处的值发生了变化，不能重复利用动规数组的值求解。问题又需要通过递归求解来解决。 不选取第一个戳破的气球，选取最后一个被戳破的气球 `k` ，那么最后获得金币就一定是 `nums[i]*nums[k]*nums[j]` 。此时由于k是最后一个，那么对应的区间也就是 `dp[i][j]=max(dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])` 其中 `k=i+1,...,j-1` 
3. 初始化：全部初始化为0
4. 遍历顺序：从下往上，从左往右逐行遍历

```C++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n=nums.size();
        vector<vector<int>> dp(n+2,vector<int>(n+2,0));
        vector<int> nums2;
        nums2.push_back(1);
        for(int i=0;i<n;i++) nums2.push_back(nums[i]);
        nums2.push_back(1);
        for(int i=n-1;i>-1;i--){
            for(int j=i+2;j<n+2;j++){
                for(int k=i+1;k<j;k++){
                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+nums2[i]*nums2[k]*nums2[j]);
                }
            }
        }
        return dp[0][n+1]; 
    }
};
```
