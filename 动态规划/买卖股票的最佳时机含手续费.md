# LeetCode-714-买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]` 表示第 i 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

## 动态规划

此处的手续费是固定的。

1. 动规数组：定义 `dp[i][2]` 表示
   1. `dp[i][0]` 表示第 `i` 天不持有股票的最大利润
   2. `dp[i][1]` 表示第 `i` 天持有股票的最大利润
2. 推导
   1. 对于 `dp[i][0]` 前一天可能持有也可能不持有 `dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]-fee)`
   2. 对于 `dp[i][1]` 前一天可能持有也可能不持有 `dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])`
3. 初始化：`dp[0][0]=0,dp[0][1]=-prices[0]`
4. 遍历顺序：从前向后

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n=prices.size();
        vector<vector<int>> dp(2,vector<int>(2,0));
        dp[0][1]=-prices[0];
        for(int i=1;i<n;i++){
            dp[i%2][0]=max(dp[(i-1)%2][0],dp[(i-1)%2][1]+prices[i]-fee);
            dp[i%2][1]=max(dp[(i-1)%2][1],dp[(i-1)%2][0]-prices[i]);
        }
        return max(dp[(n-1)%2][0],dp[(n-1)%2][1]);
    }
};
```

此处也可以使用贪心，将每次能够赚到的钱都赚到，但是使用贪心存在这样的问题：就是当股票价格 `prices[i]` 大于 buy，那么我们直接卖出股票并且获得 `prices[i]−buy` 的收益。但实际上，我们此时卖出股票可能并不是全局最优的（例如下一天股票价格继续上升），此处的根本原因就在于，再次进行买卖是需要手续费。

