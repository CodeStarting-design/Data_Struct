# 397. 整数替换

给定一个正整数 n ，你可以做如下操作：

1. 如果 n 是偶数，则用 n / 2替换 n 。
2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。

返回 n 变为 1 所需的 最小替换次数 。

暴力递归：不断尝试

记忆化搜索：

```c++
class Solution {
public:
    unordered_map<int,int> nums;
    int integerReplacement(int n) {
        if(n==1)return 0;
        if(nums.count(n)) return nums[n];
        if(n%2){
            return nums[n]=min(integerReplacement(n/2),integerReplacement(n/2+1))+2;
        }
        return nums[n]=integerReplacement(n/2)+1;
    }
};
```

重点处理 `n=INT_MAX` 的情形，+1，-1之后一定是偶数，那么就除2，只有 `n/2,n/2+1` 两种情形。

贪心+位运算：

减一一定是最后一位的1消失了，那么总体就少了一个1，加一操作最后一个1消失但是可能导致前置的1增加，所以贪心贪的是如何操作让1的个数减少。

此处将奇数划分为两种情况：

1. 第一个是除4余1的情况，那么此时就应该执行减一操作，因为减一之后是的4倍数，可以进行两次除2操作，总计的操作次数是3。
   - 那么若是进行加一操作，那么除2之后还是一个奇数，此时还需要再-1，然后到达与原来相同的状态。
   - 或者在加1除二之后，再进行一次加一，除2，得到 $(n+3)/4$（总计操作了4次），那么对于 $(n-1)/4$ 只需要再加一，也能够在4次操作的范围中得到相同的数值，因此对于当前-1一定是最优秀的。 
2. 第二个是除4余3，加1成为4的倍数，直接两次除二，得到的是 $(n+1)/4$
   - 减一则在除完之后 $(n-1)2$ 是一个奇数，若是此时加1再除2得到是 $(n+1)/4$ 和之前一样
   - 若是再次减一再除2，那么得到的是 $(n-3)/4$ ，那么对于初始加一的情况，只需要再-1，那么操作次数是相同的，所处的状态是相同的

```C++
class Solution {
public:
    int integerReplacement(int n) {
       // 基于循环实现即可
        int ans=0;
        while(n!=1){
            if(n%2==0){
                n=n/2;
                ans++;
            }else if(n%4==1){
                n=n/2;
                ans+=2;
            }else if(n==3){
                ans+=2;
                break;
            }
            else if(n%4==3){
                n=n/2+1;
                ans+=2;
            }
        }
        return ans;
    }
};
```
