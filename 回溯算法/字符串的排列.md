# LCR-014-字符串的排列

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 子串 。

## 暴力回溯

此处首先是子串匹配的问题，其次是允许对s1进行顺序的排列。（暴力的解法就是穷举出s1排列的全部情形，然后做子串的判断）

这样的做法基本上一定会导致超时。

## 滑动窗口

首先，需要对问题进行转换，对于s1的全排列判断是不是s2的子串，本质上就是关心s1中字符出现的顺序，那么只需要长度相等，并且包含的字符种类相等即可。

使用一个map来记录s1中每个字符出现的次数，使用一个窗口在s2上进行滑动，向前滑动一个的前提元素在数组中，并且个数不为0，那么继续向前，若是这个元素在map中值为0，那么就需要缩小窗口，如果值不存在那么map需要全部缩小。这样的处理方式，在窗口直接进行缩小存在着不好判断的问题。

## 双指针

本质还是双指针，但是简化了判断窗口，使用长度为26的数组记录，但是记录值是负数，当出现 `cnt[x]>0` 说明窗口中出现了非法值，那么开始缩减。初始的条件保证了全部小于0。此处的一个重点就是允许left跑到right的右边去。

```C++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n = s1.length(), m = s2.length();
        if (n > m) {
            return false;
        }
        vector<int> cnt(26);
        for (int i = 0; i < n; ++i) {
            --cnt[s1[i] - 'a'];
        }
        int left = 0;
        for(int right =0;right<m;right++){
            // 取right处的值
            int i=s2[right]-'a';
            cnt[i]++;
            while(cnt[i]>0){
                cnt[s2[left++]-'a']--;
            }
            if(right-left+1==n)return true;
        }
        return false;
    }
};
```
